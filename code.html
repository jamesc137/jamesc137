<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>James Calhoun</title>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-180553334-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-180553334-1');
    </script>
    <!-- OGP -->
    <meta property="og:title" content="James Calhoun - Entrepreneur"/>
    <meta property="og:description" content="James Calhoun - Entrepreneur"/>
    <meta property="og:url" content="https://jamescalhoun.co" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Fav Icon -->
    <link rel="icon" href="favicon.ico" type="image/x-icon"/>
    <!-- Site CSS -->
    <link href="public/css/site.css" rel="stylesheet" type="text/css">
    <link href="public/css/components.css" rel="stylesheet" type="text/css">
    <link href="public/css/gradients.css" rel="stylesheet" type="text/css">
    <link href="public/css/animations.css" rel="stylesheet" type="text/css">
    <link href="public/css/lavalamp.css" rel="stylesheet" type="text/css">
    <!-- JS -->
    <script type="text/javascript" src="public/js/jquery.min.js"></script>
    <script type="text/javascript" src="public/js/site.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  </head>
  <body>
    <div class="container">

      <!-- Open AI -->
      <h1 class="center">Code Examples</h1>
      <h2>‚öõÔ∏è Open AI</h2>
      <p>Welcome OpenAI team member! The following page will walk you through some code I've written for BitNations.</p>

      
      <ol>
        <li><a href="#game_manager">Game Manager & Nation Issues</a></li>
        <li><a href="#gdp">GDP</a></li>
        <li><a href="#war">Multiplayer Combat (War)</a></li>
      </ol>

      <h3>üèôÔ∏è BitNations</h3>

      <p>BitNations is a multiplayer, online nation sim written in Ruby on Rails using Postgres databases.</p>
      <p>The general game play is straight forward. The user selects the "Next" button from the UI. This action then triggers the 'progress' method which then progresses the user's nation one turn.</p>

      <h3 class="center" id="game_manager">The Game Manager</h3>
      
      <p>
        The game is run by a "Game Manager" class. In this class, we define the 'progress' method seen below.
        When a nation is progressed one turn, A LOT of things happen. For now, let's focus on the high level things.
      </p>

      <pre class="prettyprint lang-rb">
        class GameManager < ApplicationRecord
          
          private

          def self.progress(nation)
            NationIssue.generate_new_nation_issues(nation)
            .
            .
            .
          end
        end
      </pre>

      <p>With each turn, there is a chance that the nation will recieve an in-game "issue". <a href="https://bitnations.co/issues_guide" target="_blank">Issues</a>
        are scenarios with choices that the user must decide on, the result of which impacts the user's nation in various ways. Generating these issues is done
        in the NationIssue class:
      </p>

      <pre class="prettyprint lang-rb">
        class NationIssue < ApplicationRecord

          def self.generate_new_nation_issues(nation)
            chance = rand(0..1)
            return unless chance <= 0.25

            approved_issues = Issue.approved
            issues = approved_issues.in_category(nation.age)
                                  .not_resolved_by(nation)
                                  .ordered_by_narrative
                                  .limit(1)
            issues.each do |issue|
              NationIssue.create(issue_id: issue.id, nation_id: nation.id)
            end
          end

        end
      </pre>

      <p>Before digging into this method, let's take a tiny step back and discover why we have two classes, "Issue" and "NationIssue".</p>
      <p>
        One requirement for this project is to provide an Admin Dashboard where a Admin User can edit certain aspects within the game.
        The primary reason for this is to be able to adjust game play without needing to write code and re-deploy the application. Issues are
        one such thing that are editable by an Admin User.
      </p>
      <p>The <u>Issue</u> class is for Admin User and User submitted Issues. It contains the details about the issue such as the title, choices, and consequences.</p>
      <p>The <u>NationIssue</u> class is used to reference an Issue.</p>

      <pre class="prettyprint lang-rb">
        class NationIssue < ApplicationRecord
          before_update :resolved_issue
        
          belongs_to :issue
          belongs_to :nation
        end
      </pre>

      <p>
        Since Issues are submitted by Users, they must first be reviewed and approved by a Moderator. Once this is done, the attribute "approved" is saved to the database as "true".
        We can then add this scope to the Issue model so that we can easily get a list of approved issues like this:
      </p>

      <pre class="prettyprint lang-rb">
        class Issue < ApplicationRecord
    
          scope :approved, -> {
            where(approved: true)
          }

        end
      </pre>

      <pre class="prettyprint lang-rb">
        approved_issues = Issue.approved
      </pre>

      <p>
        Next, we now need to determine what issues are to appear for this nation. As there are many <a href="https://bitnations.co/ages_guide" target="_blank">economic ages</a>
        that nations progress through, the types of issues that arise should be relevant to the age the user is in.
      </p>
      <p>
        Below, we are selecting issues from the approved_issues array in which the "category" attribue matches the nation's current economic age.
      </p>
      
      <pre class="prettyprint lang-rb">
        approved_issues.in_category(nation.age)
      </pre>


      <p>
        Lastly, we want to ensure that issues a nation has already responded to, do not appear again for the same nation
        And that if there is any narrative, issues are picked in order of the narrative they may follow.
      </p>

      <pre class="prettyprint lang-rb">
        .not_resolved_by(nation)
        .ordered_by_narrative
      </pre>

      <p>
        Now we can generate the issues that match our criteria based on the array 
      </p>

      <pre class="prettyprint lang-rb">
        issues.each do |issue|
          NationIssue.create(issue_id: issue.id, nation_id: nation.id)
        end
      </pre>

      <p>
        You may be wondering why we would decide to do issues.each to create multiple issues while previously only limiting the slection of issues to one.
        This is because based on user feedback we decided to limit issues to one at a time, however we may want to support multiple issues again in the future.
        As well, issues is an array in which we know the max length will only be 1.
      </p>

      <h3 class="center" id="gdp">How is GDP calculated?</h3>

      <p>
        Previously, we looked at how a nation progresses and how NationIssues are randomly generated on each turn. There are many more things that occur when a Nation progresses.
        One of those things is calculating the nation's GDP, also known as Gross Domestic Product, a standard KPI for economic performance used by governments and economists.
      </p>

      <p>First, let's look at the equation for GDP in the real world:</p>

      <p>GDP = C + G + I + NX</p>
      <p>Where...</p>
      <ul>
        <li>C = Consumer Spending</li>
        <li>G = Government Spending</li>
        <li>I = Private Investment</li>
        <li>NX = Imports - Exports</li>
      </ul>
      
      <pre class="prettyprint lang-rb">
        class Economy < ApplicationRecord
          belongs_to :nation

          private

          def self.calculate_GDP(nation, treasury, economy, population, budget, military)
            consumer_spending  = 0.0
            private_investment = 0.0
            Population.demographics.each do |key, val|
              census = population[key]
              income = population[key + '_income']
              tax_rate = treasury[key + '_tax_rate'] * 0.01
              income_after_taxes = income - (income * tax_rate)
              unless key == 'colony_class' || key == 'commercial_class'
                consumer_spending += (census * income_after_taxes) * rand(0.35..0.45)
              end
              if key == 'commercial_class'
                private_investment += (census * income_after_taxes) * rand(0.1..0.15)
              end
            end
            government_spending = budget.total + treasury.military_spending
            import_exports = 0
            economy.gdp = consumer_spending + 
                          government_spending + 
                          private_investment + 
                          import_exports
            economy.save
          end

        end
      </pre>

      <p>
        Above you can see the import_exports (NX) is set to 0. This is because although the Trade functionality has been launched in the game, there is currently no tracking
        the value of trades to keep a tally of import and exports. This will be implemented in the near future, so for now it is defaulted to 0.
      </p>

      <pre class="prettyprint lang-rb">
        class Population < ApplicationRecord
          belongs_to :nation
          validate :validate_stats, on: :update
        
          enum demographics: {
            lower_class: "üë®üèº‚Äçüåæ Lower Class",
            middle_class: "üë®üèª‚Äçüè≠ Middle Class",
            upper_class: "ü§µüèª Upper Class",
            colony_class: "üèò Colony",
            commercial_class: "üè¢ Corporate"
          }
        end
      </pre>

      <p>
        The Treasury model contains an enum of the different tax brackets. The tax brackets corresponsd to the Population demographics in the key names
        which is why in the calculate_GDP method, we can do our each loop on Population.demogaraphics and use population[key + '_income'] or '_tax_rate'.
      </p>

      <pre class="prettyprint lang-rb">
        class Treasury < ApplicationRecord
          belongs_to :nation
          validate :set_taxes, on: :update
        
          enum brackets: {
            lower_class_tax_rate: "üë®üèº‚Äçüåæ Lower Class",
            middle_class_tax_rate: "üë®üèª‚Äçüè≠ Middle Class",
            upper_class_tax_rate: "ü§µüèª Upper Class",
            colony_class_tax_rate: "üèò Colony",
            commercial_class_tax_rate: "üè¢ Corporate"
          }
        end
      </pre>

      <p>
        The Budget model has an enum which defines the difference areas of government spending that the user can budget for.
      </p>

      <pre class="prettyprint lang-rb">
        class Budget < ApplicationRecord
          belongs_to :nation
          validate :verify_purchase, on: :update
        
          enum items: {
            infrastructure: "üõ£ Infrastructure",
            public_service: "üëÆüèª‚Äç‚ôÇÔ∏è Public services",
            education: "üéì Education",
            healthcare: "üè• Healthcare"
          }
        end
      </pre>

      <p>
        Here is a look at the Population table in the schema.rb to get an idea of what attributes exist.
      </p>

      <pre class="prettyprint land-rb">
        create_table "populations", force: :cascade do |t|
          t.integer "nation_id"

          t.integer "census"
          t.integer "density"
          t.float "fertility_rate"
          t.float "death_rate"

          t.integer "happiness"
          t.integer "intelligence"
          t.integer "freedom"
          t.integer "spirituality"

          t.integer "upper_class"
          t.integer "middle_class"
          t.integer "lower_class"
          t.integer "commercial_class"
          t.integer "colony_class"

          t.float "upper_class_income"
          t.float "middle_class_income"
          t.float "lower_class_income"
          t.float "commercial_class_income"
          t.float "colony_class_income"
        end
      </pre>

      <p>
        A population's income varies depending on the population's happiness, intellgience, and more. Below is how the Treasury class determines revenue based on taxation of the population.
      </p>
      
      <pre class="prettyprint land-rb">
        class TreasuryBalance < ApplicationRecord

          def self.calculate(treasury, population, budget, military)
            monthly_income = TreasuryBalance.revenue(treasury, population)
            budget_spending = TreasuryBalance.budget(budget, monthly_income)
            military_spending = TreasuryBalance.military(military)
            total_expenses = (budget_spending + military_spending).round(2)
            update_treasury(treasury, monthly_income, military_spending, total_expenses)
          end
          
          def self.update_treasury(treasury,monthly_income, 
                                   military_spending, total_expenses)
            treasury.update!(
              military_spending: military_spending,
              monthly_revenue: monthly_income,
              monthly_expenses: total_expenses,
              monthly_income: monthly_income - total_expenses,
              government_cash: [
                treasury.government_cash + monthly_income - total_expenses, 9999999999999.0
              ].min
            )
          end
        end
      </pre>

      <p>Calculating revenue for each population demographic in the TreasuryBalance model.</p>

      <pre class="prettyprint land-rb">
        def self.revenue(treasury, population)
          demographics = Population.demographics
          sum = 0.0
          demographics.each do |key, value|
            sum += ((population[key] * population[key + '_income']) *
            (treasury[key + '_tax_rate'] * 0.01)) / 100
          end
          return sum.round(2)
        end
      </pre>


      <h3 class="center" id="war">Multiplayer War!</h3>

      <p>This section coming soon.</p>


    </div>
  </body>
</html>


